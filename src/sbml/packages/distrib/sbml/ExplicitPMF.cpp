/**
 * @file:   ExplicitPMF.cpp
 * @brief:  Implementation of the ExplicitPMF class
 * @author: Generated by autocreate code
 *
 * <!--------------------------------------------------------------------------
 * This file is part of libSBML.  Please visit http://sbml.org for more
 * information about SBML, and the latest version of libSBML.
 *
 * Copyright (C) 2009-2013 jointly by the following organizations:
 *     1. California Institute of Technology, Pasadena, CA, USA
 *     2. EMBL European Bioinformatics Institute (EBML-EBI), Hinxton, UK
 *
 * Copyright (C) 2006-2008 by the California Institute of Technology,
 *     Pasadena, CA, USA 
 *
 * Copyright (C) 2002-2005 jointly by the following organizations:
 *     1. California Institute of Technology, Pasadena, CA, USA
 *     2. Japan Science and Technology Agency, Japan
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation.  A copy of the license agreement is provided
 * in the file named "LICENSE.txt" included with this software distribution
 * and also available online as http://sbml.org/software/libsbml/license.html
 * ------------------------------------------------------------------------ -->
 */


#include <sbml/packages/distrib/sbml/ExplicitPMF.h>


using namespace std;


LIBSBML_CPP_NAMESPACE_BEGIN


/*
 * Creates a new ExplicitPMF with the given level, version, and package version.
 */
ExplicitPMF::ExplicitPMF (unsigned int level, unsigned int version, unsigned int pkgVersion)
	: SBase(level, version)
	 ,mXmlns ("")

{
	// set an SBMLNamespaces derived object of this package
	setSBMLNamespacesAndOwn(new DistribPkgNamespaces(level, version, pkgVersion));

	// connect to child objects
	connectToChild();
}


/*
 * Creates a new ExplicitPMF with the given DistribPkgNamespaces object.
 */
ExplicitPMF::ExplicitPMF (DistribPkgNamespaces* distribns)
	: SBase(distribns)
	 ,mXmlns ("")

{
	// set the element namespace of this object
	setElementNamespace(distribns->getURI());

	// connect to child objects
	connectToChild();

	// load package extensions bound with this object (if any) 
	loadPlugins(distribns);
}


/*
 * Copy constructor for ExplicitPMF.
 */
ExplicitPMF::ExplicitPMF (const ExplicitPMF& orig)
	: SBase(orig)
{
	if (&orig == NULL)
	{
		throw SBMLConstructorException("Null argument to copy constructor");
	}
	else
	{
		mXmlns  = orig.mXmlns;

		// connect to child objects
		connectToChild();
	}
}


/*
 * Assignment for ExplicitPMF.
 */
ExplicitPMF&
ExplicitPMF::operator=(const ExplicitPMF& rhs)
{
	if (&rhs == NULL)
	{
		throw SBMLConstructorException("Null argument to assignment");
	}
	else if (&rhs != this)
	{
		SBase::operator=(rhs);
		mXmlns  = rhs.mXmlns;

		// connect to child objects
		connectToChild();
	}
	return *this;
}


/*
 * Clone for ExplicitPMF.
 */
ExplicitPMF*
ExplicitPMF::clone () const
{
	return new ExplicitPMF(*this);
}


/*
 * Destructor for ExplicitPMF.
 */
ExplicitPMF::~ExplicitPMF ()
{
}


/*
 * Returns the value of the "xmlns" attribute of this ExplicitPMF.
 */
const std::string&
ExplicitPMF::getXmlns() const
{
	return mXmlns;
}


/*
 * Returns true/false if xmlns is set.
 */
bool
ExplicitPMF::isSetXmlns() const
{
	return (mXmlns.empty() == false);
}


/*
 * Sets xmlns and returns value indicating success.
 */
int
ExplicitPMF::setXmlns(const std::string& xmlns)
{
	if (&(xmlns) == NULL)
	{
		return LIBSBML_INVALID_ATTRIBUTE_VALUE;
	}
	else
	{
		mXmlns = xmlns;
		return LIBSBML_OPERATION_SUCCESS;
	}
}


/*
 * Unsets xmlns and returns value indicating success.
 */
int
ExplicitPMF::unsetXmlns()
{
	mXmlns.erase();

	if (mXmlns.empty() == true)
	{
		return LIBSBML_OPERATION_SUCCESS;
	}
	else
	{
		return LIBSBML_OPERATION_FAILED;
	}
}


/*
 * Returns the XML element name of this object
 */
const std::string&
ExplicitPMF::getElementName () const
{
	static const string name = "explicitPMF";
	return name;
}


/*
 * Returns the libSBML type code for this SBML object.
 */
int
ExplicitPMF::getTypeCode () const
{
	return SBML_DISTRIB_EXPLICT_PMF;
}


/*
 * check if all the required attributes are set
 */
bool
ExplicitPMF::hasRequiredAttributes () const
{
	bool allPresent = true;

	if (isSetXmlns() == false)
		allPresent = false;

	return allPresent;
}


/*
 * check if all the required elements are set
 */
bool
ExplicitPMF::hasRequiredElements () const
{
	bool allPresent = true;

	return allPresent;
}


	/** @cond doxygen-libsbml-internal */

/*
 * write contained elements
 */
void
ExplicitPMF::writeElements (XMLOutputStream& stream) const
{
	SBase::writeElements(stream);
	SBase::writeExtensionElements(stream);
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Accepts the given SBMLVisitor.
 */
bool
ExplicitPMF::accept (SBMLVisitor& v) const
{
	return false;

}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Sets the parent SBMLDocument.
 */
void
ExplicitPMF::setSBMLDocument (SBMLDocument* d)
{
	SBase::setSBMLDocument(d);
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
	 * Connects to child elements.
 */
void
ExplicitPMF::connectToChild()
{
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Enables/Disables the given package with this element.
 */
void
ExplicitPMF::enablePackageInternal(const std::string& pkgURI,
             const std::string& pkgPrefix, bool flag)
{
	SBase::enablePackageInternal(pkgURI, pkgPrefix, flag);
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * creates object.
 */
SBase*
ExplicitPMF::createObject(XMLInputStream& stream)
{
	const string& name = stream.peek().getName();
	SBase* object = NULL;


	return object;
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Get the list of expected attributes for this element.
 */
void
ExplicitPMF::addExpectedAttributes(ExpectedAttributes& attributes)
{
	SBase::addExpectedAttributes(attributes);

	attributes.add("xmlns");
}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Read values from the given XMLAttributes set into their specific fields.
 */
void
ExplicitPMF::readAttributes (const XMLAttributes& attributes,
                             const ExpectedAttributes& expectedAttributes)
{
	SBase::readAttributes(attributes, expectedAttributes);

	bool assigned = false;

	//
	// xmlns string   ( use = "required" )
	//
	assigned = attributes.readInto("xmlns", mXmlns, getErrorLog(), true);

	if (assigned == true)
	{
		// check string is not empty

		if (mXmlns.empty() == true)
		{
			logEmptyString(mXmlns, getLevel(), getVersion(), "<ExplicitPMF>");
		}
	}

}


	/** @endcond doxygen-libsbml-internal */


	/** @cond doxygen-libsbml-internal */

/*
 * Write values of XMLAttributes to the output stream.
 */
	void
ExplicitPMF::writeAttributes (XMLOutputStream& stream) const
{
	SBase::writeAttributes(stream);

	if (isSetXmlns() == true)
		stream.writeAttribute("xmlns", getPrefix(), mXmlns);

	SBase::writeExtensionAttributes(stream);

}


	/** @endcond doxygen-libsbml-internal */


/**
 * write comments
 */
LIBSBML_EXTERN
ExplicitPMF_t *
ExplicitPMF_create(unsigned int level, unsigned int version,
                   unsigned int pkgVersion)
{
	return new ExplicitPMF(level, version, pkgVersion);
}


/**
 * write comments
 */
LIBSBML_EXTERN
void
ExplicitPMF_free(ExplicitPMF_t * epmf)
{
	if (epmf != NULL)
		delete epmf;
}


/**
 * write comments
 */
LIBSBML_EXTERN
ExplicitPMF_t *
ExplicitPMF_clone(ExplicitPMF_t * epmf)
{
	if (epmf != NULL)
	{
		return static_cast<ExplicitPMF_t*>(epmf->clone());
	}
	else
	{
		return NULL;
	}
}


/**
 * write comments
 */
LIBSBML_EXTERN
char *
ExplicitPMF_getXmlns(ExplicitPMF_t * epmf)
{
	if (epmf == NULL)
		return NULL;

	return epmf->getXmlns().empty() ? NULL : safe_strdup(epmf->getXmlns().c_str());
}


/**
 * write comments
 */
LIBSBML_EXTERN
int
ExplicitPMF_isSetXmlns(ExplicitPMF_t * epmf)
{
	return (epmf != NULL) ? static_cast<int>(epmf->isSetXmlns()) : 0;
}


/**
 * write comments
 */
LIBSBML_EXTERN
int
ExplicitPMF_setXmlns(ExplicitPMF_t * epmf, const char * xmlns)
{
	return (epmf != NULL) ? epmf->setXmlns(xmlns) : LIBSBML_INVALID_OBJECT;
}


/**
 * write comments
 */
LIBSBML_EXTERN
int
ExplicitPMF_unsetXmlns(ExplicitPMF_t * epmf)
{
	return (epmf != NULL) ? epmf->unsetXmlns() : LIBSBML_INVALID_OBJECT;
}


/**
 * write comments
 */
LIBSBML_EXTERN
int
ExplicitPMF_hasRequiredAttributes(ExplicitPMF_t * epmf)
{
	return (epmf != NULL) ? static_cast<int>(epmf->hasRequiredAttributes()) : 0;
}




LIBSBML_CPP_NAMESPACE_END


